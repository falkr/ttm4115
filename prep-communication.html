<html lang="en-US"><head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>TTM4115</title>
<meta property="og:title" content="TTM4115">
<meta property="og:locale" content="en_US">
<meta name="description" content="Design of Communicating Systems">
<meta property="og:description" content="Design of Communicating Systems">


<!--<link rel="stylesheet" type="text/css" href="style.css" />-->
<link href="https://fonts.googleapis.com/css?family=Merriweather:400,400italic,700,700italic|Source+Code+Pro|Source+Sans+Pro:200,300,400,600,400italic,600italic|Rock+Salt" rel="stylesheet" type="text/css">


<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>


<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.1/css/all.css" integrity="sha384-gfdkjb5BdAXd+lj+gudLWI+BXq4IuLW5IT+brZEZsLFm++aCMlF1V92rMkPaX4PP" crossorigin="anonymous">


<link rel="stylesheet" type="text/css" href="assets/style.css" />
<link rel="stylesheet" type="text/css" href="assets/bootstrap-icons.css">

<script src="assets/anchor.js"></script>
<script src="assets/script-aside.js"></script>
</head>
<body id="top">

<nav class="navbar navbar-expand-md navbar-dark " style="background-color:#666666"#2B65EC"> <!-- fixed-top -->
        <ul class="nav nav-pills">
        <li class="nav-item">
    <a class="nav-link" href="index.html" style="font-weight: bold")>TTM4115</a>
  </li>
        
  <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false">Preparation</a>
    <div class="dropdown-menu">
      <a class="dropdown-item" href="prep-setup.html">Introduction and Setup</a>
      <div class="dropdown-divider"></div>
      <a class="dropdown-item" href="prep-modeling.html">Modeling and Deployment</a>
      <a class="dropdown-item" href="prep-statemachines.html">State Machines</a>
      <a class="dropdown-item" href="prep-user-requirements.html">User Requirements</a>
      <a class="dropdown-item" href="prep-stmpy.html">State Machines in Python</a>
      <a class="dropdown-item" href="prep-agile.html">Agile Development</a>
      <a class="dropdown-item" href="prep-communication.html">Communication</a>
      <a class="dropdown-item" href="prep-interactions.html">Interactions</a>
      <a class="dropdown-item" href="prep-components.html">Components</a>
    </div>
  </li>
  
  <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false">Activities</a>
    <div class="dropdown-menu">
      <a class="dropdown-item" href="unit-setup.html">Team Setup</a>
      <div class="dropdown-divider"></div>
      <a class="dropdown-item" href="unit-modeling.html">Modeling and Deployment</a>
      <a class="dropdown-item" href="unit-statemachines.html">State Machines</a>
      <a class="dropdown-item" href="unit-user-requirements.html">User Requirements</a>
      <a class="dropdown-item" href="unit-stmpy.html">State Machines in Python</a>
  	  <a class="dropdown-item" href="unit-agile.html">Agile Development</a>
      <a class="dropdown-item" href="unit-communication.html">Communication</a>
      <a class="dropdown-item" href="unit-interactions.html">Interactions</a>
      <a class="dropdown-item" href="unit-components.html">Components</a>

      <div class="dropdown-divider"></div>
	  <a class="dropdown-item" href="unit-modeling-diagram-tips.html">Focus: Diagram Tips</a>
      <a class="dropdown-item" href="unit-statemachines-data.html">Focus: State Machines — Data vs. States</a>
	  <a class="dropdown-item" href="unit-statemachines-car.html">Focus: State Machines — Car Lock Example</a>
    </div>
  </li>
  
  <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false">Deliveries</a>
    <div class="dropdown-menu">
      <a class="dropdown-item" href="deliveries.html">Deliveries Overview</a>
      <!--<a class="dropdown-item" href="project.html">Project</a>-->
      <div class="dropdown-divider"></div>
      <a class="dropdown-item" href="deliveries-t1.html">System Spec, version 1</a>
      <a class="dropdown-item" href="deliveries-i1.html">Feedback on version 1</a>
      <div class="dropdown-divider"></div>
      <a class="dropdown-item" href="deliveries-t2.html">System Spec, version 2</a>
      <a class="dropdown-item" href="deliveries-i2.html">Feedback on version 2</a>
      <div class="dropdown-divider"></div>
      <a class="dropdown-item" href="deliveries-t3.html">System Spec, final version</a>
      <a class="dropdown-item" href="deliveries-i3.html">Individual Reflection</a>
    </div>
  </li>

  <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false">Tools</a>
    <div class="dropdown-menu">
      <a class="dropdown-item" href="tools.html">Tools Overview</a>
      <div class="dropdown-divider"></div>
      <a class="dropdown-item" href="tools-python.html">Python</a>
	    <a class="dropdown-item" href="tools-gui.html">Python GUIs with appJar</a>
      <a class="dropdown-item" href="tools-notebooks.html">Python Notebooks</a>
      <a class="dropdown-item" href="tools-mqtt.html">MQTT</a>
      <a class="dropdown-item" href="tools-stmpy.html">STMPY</a>
	  <a class="dropdown-item" href="tools-base.html">Base Architecture</a>
    </div>
  </li>
  
  <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false">Learning</a>
    <div class="dropdown-menu">
      <a class="dropdown-item" href="learning-goals.html">Learning Goals</a>
      <a class="dropdown-item" href="learning-tbl.html">Team-Based Learning</a>
      <a class="dropdown-item" href="learning-teamwork.html">Teamwork Procedures</a>
      <a class="dropdown-item" href="learning-reflection.html">Reflection</a>
      <a class="dropdown-item" href="feedback.html">Feedback</a>
      <a class="dropdown-item" href="learning-grading.html">Grading</a>
      <!--<a class="dropdown-item" href="learning-areas.html">Working Areas</a>-->
      <!--<a class="dropdown-item" href="learning-expectations.html">Expectations</a>-->
    </div>
  </li>
  <!--
  <li class="nav-item">
    <a class="nav-link" href="#">Blackboard</a>
  </li>-->
</ul>

<div class="navbar-nav flex-row ml-md-auto d-none d-md-flex"></div>
             <a class="navbar-brand" href="https://ntnu.edu" title="NTNU Homepage">
      	<svg width="100" height="30">
      		<image xlink:href="https://innsida.ntnu.no/innsida-theme/images/ntnu-graphics/ntnu_logo_white.svg" 
      		src="https://innsida.ntnu.no/innsida-theme/images/ntnu-graphics/ntnu_logo_white.png" width="100%" height="100%" alt="NTNU Logo"></image>
      	</svg>
      </a>
    </nav>


<div class="page">
    </section>
    <section class="content">
<h1 id="communication">Communication</h1>
<p>In this unit, we will have a look at communication at the level of an application. This means, we will learn how communication protocols influence our application logic. We will also study some of the details of specific protocols, in particular HTTP and MQTT.</p>
<h2 id="learning-goals">Learning Goals</h2>

<div class="goals"><p>The learning goals specific for this week are the following:</p>
<ul>
<li>Recognize and recite basic communication patterns and terminology.</li>
<li>Relate communication mechanisms to each other.</li>
<li>Select proper communication patterns and topologies for a given problem.</li>
<li>Reciting the basic mechanisms of HTTP and MQTT.</li>
<li>Designing an MQTT topic structure for a given system.</li>
</ul>
</div>
<h3 id="for-the-semester-project">For the Semester Project</h3>

    </section>
    <section class="content">
<h1 id="communication-protocols">Communication Protocols</h1>
<p>Communication protocols easily fill a course on their own, because there are so many of them and because they rely on a lot of mechanisms that are worth studying. You have probably already learned about protocols like TCP and HTTP. In the following, we will have a look at protocols from the viewpoint of an application. From this perspective, we are concerned with the entire system, the user requirements and also the development process to build that system.</p>

<div class="figure">
<img src="figures/communication/wifi_vs_cellular.png" alt="Communication fails, and we are used to it. From XKCD, https://xkcd.com/1865/" width="100%"/>
<span name="figures/communication/wifi_vs_cellular.png">&nbsp;</span>
<aside name="figures/communication/wifi_vs_cellular.png"><p><p>Communication fails, and we are used to it. From XKCD, https://xkcd.com/1865/</p>
</p></aside>
</div>
<p>Communication between components has a great influence on the system, its performance, its behavior, its robustness and its security, to name a few. Communication is probably most brittle part of our logic, since it depends on many factors that we don’t have control over. For instance, communication can <em>always</em> fail, either because the communication channel has errors, or our communication partner failed. Communication often takes a long time compared to local operations that we have more control over. We are never sure about the state of our system until we receive something back.</p>
<p>There are different strategies to integrate the challenges with communication into an application. In most cases, you will not implement all communication logic from scratch, but use a library, for instance to make an HTTP call or accept incoming UDP packages. This of course simplifies the implementation. Once a library for communication gets very advanced and introduces assumptions about your architecture, we also call them a framework or a middleware. There are communication frameworks that use more basic communication mechanisms, add logic on top of them and offer simpler application development. They take for instance care of some failure management and guarantee some system properties. They may also provide a uniform interface to several protocols, so that it is, for instance, possible to talk to other components no matter how they are connected. However, we still need to take into account that communication fails, may have to re-send messages, or tell the user that something is wrong. So even good middleware, libraries of framework don’t free you from the problems of communication; they may however, make life much easier.</p>

<div class="figure">
<img src="figures/communication/communication-errors.jpg" width="100%"/>
</div>
<p>Let’s have a look at three very different applications:</p>
<ul>
<li><p>A wireless <strong>temperature</strong> sensor sends the temperature every ten minutes to a receiver that logs the temperature. The communication in between the two uses some wireless protocol, for instance Bluetooth or Zigbee. In this case, it may be appropriate to not do anything specific when the transmission fails. A failed transmission means one data point less, which may be acceptable. Of course, the user should see somehow if the communication works most of the time, for instance by showing how old the last measurement is and maybe blinking as a conformation when a new measurement was received.</p></li>
<li><p>An electronic <strong>body weight scale</strong> offers automatic logging to an iPhone app via Bluetooth. Here, each measurement is more valuable to the user, since they make this measurement less often and want to log it. However, also here the communication can fail, for instance when the phone is out of reach or Bluetooth is turned off. Like with the temperature sensor, communication could simply fail, possibly also notifying the user. A more advanced handling is to store the value that has not been transmitted and send it once the phone is in reach again next time.</p></li>
<li><p>A third example is a <strong>home automation system</strong>. Here it can be much more critical to handle communication properly, as for instance activating monitoring remotely. Existing systems often use several communication channels at the same time. By default, commands from a remote user can be sent from their mobile phone over the alarm company’s servers using the broadband connection of the house. The broadband connection is subject to failure. If the first sending fails, the app tries to send once again. At the same time, the command is put into a queue and the user can continue to use the app. If the sending fails once again, the app can switch communication modes an try to send the command as a coded SMS to the home gateway directly, since it also has its own mobile connection. Since, however, the user has to pay for this service, the app asks the user if the command should be sent this way.</p></li>
</ul>
<p>All of these applications can be based on the same protocol, but on their application level they handle communication very differently. The temperature sensor offers no special logic, and just accepts communication to fail. The body weight scale offers some compensation that seems reasonable. The home automation system escalates the failure and involves the user to make decisions, simply because the command is important to transmit.</p>

    </section>
    <section class="content">
<h1 id="basic-terms-and-mechanisms">Basic Terms and Mechanisms</h1>
<p>Communication protocols determine rules that lets two or more entities communicate with each other. They describe, for instance, how data is serialized, how data is encrypted, or how errors are handled. In the following, we look at communication by starting with the different message exchange patterns, and study the different topologies. But before that, let’s look at some basic terms and concept that make things easier to understand.</p>
<p>Communication happens between <strong>components</strong>, which are simply parts of the system. Depending on how many details of a system we know, or on which level of detail we want to describe it, a component can be different things. It can be an application, a web server, a web browser, or a device.</p>
<p>Roles during communication: A <strong>sender</strong> is the originator of some communication, and a <strong>receiver</strong> accepts the communication. In many forms of communication, a component can be both sender and receiver, and depending on the pattern there can be several senders or receivers. When we want to express who started (or <em>initialed</em>) a communication, we refer to that role as the <strong>initiator</strong>.</p>
<p>Components communicate via <strong>interfaces</strong>. These are simply some defined points in a system dedicated for exchanging information. Depending on which protocol of communication an interfaces uses, it can be described in different ways, and more or less formal or detailed. An interface description can tell other components for instance <em>“You can connect to me using HTTP at port 80, with the following paths. I will return...”</em> Interfaces are also often called <strong>APIs</strong>, which stands for <em>application programming interface</em>.</p>
<p>When communication happens, several mechanisms need to be in place and known to all communication partners:</p>
<ul>
<li><p><strong>Serialization</strong> means to transform some piece of data, like a number or a name or a record of more complex data, into a series of bits and bytes. This is necessary since we only can send zeroes and ones over a wire or through the air.</p></li>
<li><p><strong>Cryptographic operations</strong> to the data means to sign the data, secure it against changes or encrypt it to prevent others from reading it.</p></li>
<li><p><strong>Error handling</strong> includes to add checksums, so that corrupted data can be detected and to add sequence numbers to detect missing data or duplicate data. This also includes strategies for the communication partners for when errors are detected.</p></li>
</ul>
<p>Most protocols describe the transmission of data in chunks of bytes. Depending on the protocol, these chunks are called <em>packets</em>, <em>frames</em>, <em>messages</em> or <em>datagrams</em>. All of them have some body, also called the payload, which contains the bytes to transmit. The body is enclosed by a header and a tail, which contain information to control the protocol mechanisms, like sequence numbers and checksums.</p>
<h2 id="communication-layers-and-stacks">Communication Layers and Stacks</h2>
<p>Protocols often rely on other protocols to do their job. For instance, HTTP uses TCP, which in turn uses the IP protocol. The protocols build a communication stack, which each protocol adding some new functionalities, also called <em>services</em>. For instance, IP offers connectivity between networks using IP packets. TCP uses this functionality and offers guaranteed delivery over the lossy IP channels using a sliding window mechanism. HTTP then uses TCP to handle requests that are ideal for websites, and was later also used for REST-ful APIs.</p>

    </section>
    <section class="content">
<h1 id="topologies-architectures">Communication Topologies</h1>
<p>With topologies, we describe the patterns of the nodes and summarize some of their behavior. The following are the most important topologies:</p>
<p><strong>Client-server:</strong> The client knows the address of the server. The server gets to know the client only after the client makes initial contact. Since only the client knows the address of the server initially, it is only the clients that can make the first contact and take initiative. In the world wide web, servers can host web sites and are contacted by browsers (the clients.) This is an example where there are many clients and only few servers, and where servers are optimized to server many clients. But there are also protocols in which the server is on a tiny sensor device, and “serves” the values of the sensor to any client that is interested in them.</p>
<p><a class="arrow" href="https://en.m.wikipedia.org/wiki/Client--server\_model">Client-Server on Wikipedia</a></p>
<p><strong>Peer-to-peer:</strong> A peer is a node in a communication scenario. The word peer emphasizes that the nodes are equivalent, and each node can both send and receive messages, that means the communication is symmetric. This is in contrast to the client-server model, where the communication roles are very different (also called asymmetric). Peer-to-peer topologies are often used for applications where logic is distributed among several nodes, often without a central node for coordination. Examples are peer-to-peer networks for sharing data, or the protocol for the interactions used in blockchain protocols and currencies like Bitcoin.</p>
<p><a class="arrow" href="https://en.m.wikipedia.org/wiki/Peer-to-peer">Peer to Peer on Wikipedia</a></p>

<p><strong>Broker:</strong> A message broker is a server that distributes messages. The message broker usually does not care about the specific application or the content of the message. Clients communicate with the server and send messages to the broker, which then get distributed to those clients that are interested in the events.</p>
<p><a class="arrow" href="https://en.m.wikipedia.org/wiki/Broker\_Pattern">Broker on Wikipedia</a></p>

    </section>
    <section class="content">
<h1 id="message-exchange-patterns">Message Exchange Patterns</h1>
<p>Communication happens by sending messages. Communication patterns describe in which sequence and directions messages are sent to communicate. Many protocols use similar message exchange patterns.</p>
<h2 id="single-message">Pattern: Single Message</h2>
<p>The simplest pattern is a single message, sent from the sender to the receiver. The message can contain data or be empty.</p>

<div class="figure">
<img src="figures/communication/single-message.svg" width="100%"/>
</div>
<p>Communication channels can be disturbed or disrupted, and messages can get lost.</p>

<div class="figure">
<img src="figures/communication/single-message-lost.svg" width="100%"/>
</div>
<h2 id="request-response">Pattern: Request-Response</h2>
<p>The requestor sends a message, and the responder sends a response message back to the requestor. The response can contain data or be empty. The answer message or response is also called <em>acknowledgement.</em> The entire request-response pattern is also called <em>a handshake.</em></p>
<p>A typical example is when a browser requests an HTML document from a server. The request contains the address of the page and parameters. The response contains the HTML document.</p>
<p>When it is important that a message is received, the request-response pattern is often used instead of a single message. The reception of the response is a confirmation to the requestor that the request was received. In such cases, the request-response pattern is often combined with a timer on the requestor side. If the requestor does not receive a response within a given time, it sends the request again, until it receives the response.</p>

<span name="e4c801"></span><aside name="e4c801"><p>Note that we are now using the words synchronous and asynchronous for the communication pattern, not to the specific modeling element of a synchronous or asynchronous messages in sequence diagrams. In both examples, we use synchronous messages.</p>
</aside>
<p>In a <em>synchronous</em> communication, the sender and the receiver are directly connected, in the sense that the sender is not doing anything else while the communication is going on. A synchronous request-response, for instance, looks as follows:</p>

<div class="figure">
<img src="figures/communication/sync.svg" width="100%"/>
</div>
<p>In contrast, <em>asynchronous</em> communication means that the sender and the receiver are decoupled. The sender can do other things while waiting for a response, or it may not wait for a response at all.</p>

<div class="figure">
<img src="figures/communication/async.svg" width="100%"/>
</div>
<h2 id="observe">Pattern: Observe</h2>
<p>An observer can tell a server that it would like to get informed about events. Whenever the event happens, the server notifies the observer with a message.</p>

<div class="figure">
<img src="figures/communication/observer.svg" width="100%"/>
</div>
<h2 id="publish-subscribe">Pattern: Publish-Subscribe</h2>
<p>The publish-subscribe pattern is similar to the observe pattern, but involves three roles: a publisher, a message broker, and a subscriber. The broker sits in between the publisher and subscriber. It has the effect that publisher and subscriber do not have a direct connection with each other, each of them is only connected to the broker.</p>

<div class="figure">
<img src="figures/communication/publish-subscribe.svg" width="100%"/>
</div>
<h2 id="exclusive-pair">Pattern: Exclusive Pair</h2>
<p>This is the most complicated and also most general pattern. Here the two communication partners have a specific sequence of messages to get a specific job done, which depends on a specific application. The two communication partners execute a longer negotiation or conversation.</p>
<h3 id="example-application">Example: Application</h3>
<p>A mobile route planner application is an example. To get the shortest route, a user first has to set the destination, the start and send it to the route planner on a server. The route planner can then offer alternatives, and the user selects among them, before the navigation can start. This requires an interaction of signals in a specific sequence, and the application and the server exchange information in that specific sequence. For the duration of the interaction, they engage in an exclusive pair interaction. Note, however, that the API in these examples is often structured so that this interaction decomposes into a series of request-response interactions coordinated by the application.</p>
<h3 id="example-tcp">Example: TCP</h3>
<p>TCP is a protocol to provide a connection over a lossy channel (like the internet). It handles that packages are lost, duplicated, or arrive in the wrong order. To an application using TCP, these mechanisms are invisible and it appears as if the connection simply works. TCP achieves this by the rules according to which it sends the different messages in both directions. So in this sense, two components talking TCP are an exclusive pair that together execute a specific protocol.</p>

    </section>
    <section class="content">
<h1 id="http---hypertext-transfer-protocol">HTTP - Hypertext Transfer Protocol</h1>
<p>This is only a very brief description of HTTP to relate it to the previously described communication topologies and message patterns. You have probably already heard about HTTP in other courses. Here, we look at it from an application’s perspective. If you are interested in more technical details, read for instance on <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">Wikipedia</a>.</p>
<p>HTTP is a request-response message pattern, and uses a client-server topology. The server usually provides resources to the client, which can be a web browser. In HTTP, the initiatives for communication are uni-directional. This means, the client takes initiative and contacts the server, not the other way round. For the original purpose of HTTP (requesting documents from a server) this is suitable characteristic, since it simplifies the construction of efficient servers and how documents can be cached.</p>
<h2 id="getting-bi-directional" class="unnumbered">Getting Bi-Directional</h2>
<p>One websites should get more interactive, this is a limitation we are all aware of. We are used to refresh a website to see if there is new information available. And when booking a flight or paying via credit card, you see clumsy messages like “Don’t reload this page.” This is so inelegant because technology was never intended to this stuff with a browser! With this example you also see which fundamental effect communication topologies and message patterns have. Websites today are incredibly more advanced than ten years ago. Still, some of these old limitations are hard to get rid off.</p>
<p>There are some mechanisms that work around these limitations of HTTP. If you are interested in the details, have a look at the <a href="https://en.wikipedia.org/wiki/Comet_(programming)">Wikipedia article on Comet</a>. To keep it brief; it’s fascinating, but ugly. In essence, the workaround is that the client still initiates all communication, but client and server keep an HTTP connection alive, so that the server can send updates once there are some. When Google offered chat on their Gmail website, for instance, they used this mechanism to <a href="https://stackoverflow.com/questions/732705/how-is-gmail-chat-able-to-make-ajax-requests-without-client-interaction">push new chat messages immediately from the server to the browser</a>. Google Docs uses a <a href="https://stackoverflow.com/questions/35070217/what-technology-does-google-drive-use-to-get-real-time-updates">similar mechanism</a>.</p>
<p>To address the needs of server to notify the client when new information is available, the <a href="https://en.wikipedia.org/wiki/WebSocket">WebSocket protocol</a> was built. Like HTTP, it also builds upon TCP, but offers full-duplex. With WebSockets, you can for instance build relatively simple web-applications running in the browser that support fine-grained, bi-directional interactions like chat or games.</p>

    </section>
    <section class="content">
<h1 id="mqtt">MQTT</h1>
<p>MQTT is a protocol that is based on the <strong>broker</strong> topology, and that implements a <strong>publish-subscribe</strong> message pattern. MQTT was invented in 1999 by Andy Stanford-Clark from IBM and Arlen Nipper from Arcom. Today, MQTT is an Oasis standard.</p>

<span name="b32115"></span><aside name="b32115"><p>Read the article <a href="https://www.facebook.com/notes/facebook-engineering/building-facebook-messenger/10150259350998920">Building Facebook Messenger</a></p>
</aside>
<p>MQTT is often used in situations where events should be sent from many sensors and broadcast to several applications. IBM and others for instance use MQTT so that IoT devices can send updates into their cloud. When Facebook introduced their Messenger application as a standalone application, they also relied on MQTT to push messages to the clients. We consider MQTT in detail because this protocol is relatively easy to understand, introduces concepts that are used in various form also in other protocols, and because its patterns and topology is complementary to those of HTTP. When you have understood MQTT and HTTP, many other application-level protocols will be easy to understand, too. There are also some more practical reasons why we recommend you to use MQTT for the semester project:</p>

<ul>
<li><p>MQTT is simple to debug, since more than one entity can subscribe to the same topic. This means, you can work on the communication between two entities, but observe all communication by subscribing to these topics with a debugging tool.</p></li>
<li><p>You only need to handle the IP address of the MQTT broker. All other addressing happens indirectly via topics.</p></li>
<li><p>Application startup is simple. You can startup the MQTT broker first, but clients can then connect in any order after that. The MQTT broker can also be hosted on a server and be always-on.</p></li>
<li><p>MQTT works also behind a NAT, in both directions. This means you can push a message from any location to a computer that is connected to your router at home.</p></li>
</ul>
<h2 id="roles">Roles</h2>
<p>There are three roles in MQTT. The <strong>Publisher</strong> sends messages to the <strong>Broker</strong>, which then forwards them to a set of interested <strong>Subscribers</strong>.</p>
<p>A typical interaction looks as follows:</p>

<div class="figure">
<img src="figures/communication/mqtt-1.svg" width="100%"/>
</div>
<p>There can be any number of subscribers and any number of publishers in a system. Because of the publish-subscribe pattern, the subscribers do not have to know about the publishers, and the publishers do not have to know of the subscribers. They only have to know the address of the MQTT broker and connect to it.</p>
<p>The brokers only implement generic functionality, this means, they do not depend on the specific application. Therefore, the broker is a component in a system that can be reused. There are several MQTT brokers available. Examples are Mosquitto, RSMB, HiveMQ.</p>
<h2 id="topics">Topics</h2>
<p>Usually, subscribers are not interested in all messages that all publishers send. Subscribers therefore only subscribe to specific topics, which depend on the application. The topics are organized in a hierarchy, separated by a dash (“/”). The following is an example for topics that an application for home automation can use:</p>

<pre><code>house/garage/lights/l1
house/garage/lights/l2
house/garage/sensors/pi1
house/garage/doors/d1</code></pre>

<p>The light <em>l1</em> for instance subscribes to the topic <code>house/garage/lights/l1</code> so that it can receive messages that switch it on or off. The passive infrared sensor <em>pi1</em> publishes messages to the topic <code>house/garage/sensors/pi1</code> every time it detects a movement. An application to switch on the lights whenever a movement is detected can then work like this: (In pseudo code)</p>

<pre><code>subscribe to house/garage/sensors/pi1
whenever an MQTT messages arrives at house/garage/sensors/pi1:
    send a message 
        to house/garage/lights/l1 with payload &quot;on&quot;@
    
    after some time, send a message
        to house/garage/lights/l1 with payload &quot;off&quot;</code></pre>

<p>Topics can include wildcards, which make it possible for a subscriber to subscribe to several topics with a single pattern:</p>
<ul>
<li><p>The “+” is used as a wildcard for a single level</p></li>
<li><p>The “#” is used as a wildcard for several levels. It must only be placed at the end of a topic pattern.</p></li>
</ul>
<p>Examples:</p>
<ul>
<li><p>To receive all messages sent within the house, a subscriber can subscribe to <code>house/#</code></p></li>
<li><p>To receive all messages for lights in any zone (garage or kitchen), a subscriber can subscribe to <code>house/+/lights/+</code></p></li>
</ul>
<h3 id="exercise">Exercise:</h3>
<p>A publisher sends a message to the topic <code>a/b/c/d</code>. Which of the following 15 subscription topics will receive this message?</p>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: left;"><strong>Subscription Topic</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td style="text-align: left;"><code>#</code></td>
</tr>
<tr class="even">
<td>2</td>
<td style="text-align: left;"><code>+/+/+</code></td>
</tr>
<tr class="odd">
<td>3</td>
<td style="text-align: left;"><code>+/+/+/+</code></td>
</tr>
<tr class="even">
<td>4</td>
<td style="text-align: left;"><code>+/b/c/#</code></td>
</tr>
<tr class="odd">
<td>5</td>
<td style="text-align: left;"><code>+/b/c/d</code></td>
</tr>
<tr class="even">
<td>6</td>
<td style="text-align: left;"><code>a/#</code></td>
</tr>
<tr class="odd">
<td>7</td>
<td style="text-align: left;"><code>a/+/+/d</code></td>
</tr>
<tr class="even">
<td>8</td>
<td style="text-align: left;"><code>a/+/c/d</code></td>
</tr>
<tr class="odd">
<td>9</td>
<td style="text-align: left;"><code>a/b/#</code></td>
</tr>
<tr class="even">
<td>10</td>
<td style="text-align: left;"><code>a/b/c</code></td>
</tr>
<tr class="odd">
<td>11</td>
<td style="text-align: left;"><code>a/b/c/#</code></td>
</tr>
<tr class="even">
<td>12</td>
<td style="text-align: left;"><code>a/b/c/d/#</code></td>
</tr>
<tr class="odd">
<td>13</td>
<td style="text-align: left;"><code>a/b/c/d</code></td>
</tr>
<tr class="even">
<td>14</td>
<td style="text-align: left;"><code>b/+/c/d</code></td>
</tr>
<tr class="odd">
<td>15</td>
<td style="text-align: left;"><code>a/b/c/d/+</code></td>
</tr>
</tbody>
</table>
<h2 id="retained-messages">Retained Messages</h2>
<p>Imagine a temperature sensor that sends the temperature every 10 minutes. This is a sensible intervall, since temperature does not change too quickly, and the sensor should preserve its battery. When we start an application that needs the temperature in a room, it would have to wait until the sensor sends its temperature, which can be as long as about 10 minutes in the worst case.</p>

<div class="figure">
<img src="figures/communication/mqtt-retained-1.svg" alt="Scenario without retained message: The subscriber misses the last update and has to wait until the next update is published." width="100%"/>
<span name="figures/communication/mqtt-retained-1.svg">&nbsp;</span>
<aside name="figures/communication/mqtt-retained-1.svg"><p><p>Scenario without retained message: The subscriber misses the last update and has to wait until the next update is published.</p>
</p></aside>
</div>
<p>Instead, the sensor can mark its temperature message as a <strong>retained</strong> message. The broker will then store a copy of this message until it is replaced with a new message sent to the same topic. Whenever a new subscriber subscribes to the topic, it will immediately receive the retained message from the broker. In our example this means that the application does not have to wait until the sensor wakes up and sends again, but that it immediately receives the last temperature reading. (We show the reainted message with a trailing <em>R</em>.)</p>

<div class="figure">
<img src="figures/communication/mqtt-retained-2.svg" alt="Scenario with retained message: The subscriber misses the last update, but receives the retained message from the broker." width="100%"/>
<span name="figures/communication/mqtt-retained-2.svg">&nbsp;</span>
<aside name="figures/communication/mqtt-retained-2.svg"><p><p>Scenario with retained message: The subscriber misses the last update, but receives the retained message from the broker.</p>
</p></aside>
</div>
<h2 id="last-wills">Last Wills</h2>
<p>The MQTT broker monitors the connection to all clients, and detects once they do not respond anymore. Any subscriber, however, by default does not get notified once another client disappears. For instance, our temperature application would not be able to detect immediately once a temperature sensor disconnects. (It would only indirectly, because there would be no temperature readings anymore.)</p>
<p>Instead, a client can define a “last will” with the broker at the connection startup. This last will defines a message payload and a topic to which the message will be sent if the broker detects that the client suddenly disconnects. Any interested subscribers can then get notified about the sudden disconnection. If the client, however, disconnects properly from the broker, the last will message is not sent.</p>
<h2 id="quality-of-service">Quality of Service</h2>
<p>Messages can be sent with three different quality-of-service (QoS) flags, which determine how much effort the broker and the clients spend on sending them:</p>
<ul>
<li><p>QoS=0 is also called <em>At most once</em>. The message can get lost, and there will be no attempts to resend it.</p></li>
<li><p>QoS=1 is also called <em>At least once</em>. This means that the message will be eventually received, but that several copies of the message may appear due to duplication. The receiver has to detect any such duplicates.</p></li>
<li><p>QoS=2 is also called <em>Exactly once</em>. This guarantees the delivery and avoids any duplication.</p></li>
</ul>
<p>You may immediately ask: <em>If QoS=2 is available, why would one ever use any of the lower QoS levels?</em> The answer is that the highest quality of service is also more expensive with regards to transmission effort. To send a single QoS=2 message, several messages on the underlying channel are necessary. Therefore, an application should always choose the lowest QoS level it can work with. Below you see three diagrams that show how many control packages are involved to just send a single MQTT message with the different QoS levels. (The grey message arrows that start end end at the same lifeline illustrate only local operations, not communication.)</p>

<div class="figure">
<img src="figures/communication/mqtt-qos-0.svg" alt="To send one MQTT message with QoS 0, only two messages on the lower layer are necessary." width="100%"/>
<span name="figures/communication/mqtt-qos-0.svg">&nbsp;</span>
<aside name="figures/communication/mqtt-qos-0.svg"><p><p>To send one MQTT message with QoS 0, only two messages on the lower layer are necessary.</p>
</p></aside>
</div>
<div class="figure">
<img src="figures/communication/mqtt-qos-1.svg" alt="To send one MQTT message with QoS 1, at least three messages on the lower layer are necessary." width="100%"/>
<span name="figures/communication/mqtt-qos-1.svg">&nbsp;</span>
<aside name="figures/communication/mqtt-qos-1.svg"><p><p>To send one MQTT message with QoS 1, at least three messages on the lower layer are necessary.</p>
</p></aside>
</div>
<div class="figure">
<img src="figures/communication/mqtt-qos-2.svg" alt="To send one MQTT message with QoS 2, at least five messages on the lower layer are necessary." width="100%"/>
<span name="figures/communication/mqtt-qos-2.svg">&nbsp;</span>
<aside name="figures/communication/mqtt-qos-2.svg"><p><p>To send one MQTT message with QoS 2, at least five messages on the lower layer are necessary.</p>
</p></aside>
</div>
<h2 id="sequence-diagrams-on-many-levels">Sequence Diagrams on Many Levels</h2>
<p>Maybe you wondered how some of the sequence diagrams we have seen on the last pages relate to those that you develop for a specific application. Assume the application uses MQTT. What should you show then in a sequence diagram? The answer: <em>It depends on what you want to show.</em></p>
<ul>
<li><p>The diagrams <strong>Quality of Service X</strong> above show how MQTT is implemented internally and passes messages in order to publish one single message. These diagrams are only interesting when you need to understand if the MQTT protocol is suitable for your purposes, or you are concerned which QoS level to use. You will probably not use this level of detail for an application-level diagram.</p></li>
<li><p>The diagram above that shows MQTT using a retained message above is already closer to the application level, since <em>publish</em>, <em>subscribe</em> and <em>message</em> are shown as single, compact messages.</p></li>
<li><p>In some cases, it is probably interesting to show an MQTT broker as part of the sequence diagram. After all, it is a critical component in the system that requires consideration. But it may not be necessary to contain the broker in the diagrams of all use cases. Instead, the lifelines representing individual MQTT clients can directly send messages to each other, so that the application logic gets easier visible.</p></li>
</ul>

    </section>
    <section class="content">
<h1 id="solution">Solution</h1>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: left;"><strong>Topic</strong></th>
<th style="text-align: left;"><strong>Receive?</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td style="text-align: left;"><code>#</code></td>
<td style="text-align: left;">yes</td>
</tr>
<tr class="even">
<td>2</td>
<td style="text-align: left;"><code>+/+/+</code></td>
<td style="text-align: left;">no!</td>
</tr>
<tr class="odd">
<td>3</td>
<td style="text-align: left;"><code>+/+/+/+</code></td>
<td style="text-align: left;">yes</td>
</tr>
<tr class="even">
<td>4</td>
<td style="text-align: left;"><code>+/b/c/#</code></td>
<td style="text-align: left;">yes</td>
</tr>
<tr class="odd">
<td>5</td>
<td style="text-align: left;"><code>+/b/c/d</code></td>
<td style="text-align: left;">yes</td>
</tr>
<tr class="even">
<td>6</td>
<td style="text-align: left;"><code>a/#</code></td>
<td style="text-align: left;">yes</td>
</tr>
<tr class="odd">
<td>7</td>
<td style="text-align: left;"><code>a/+/+/d</code></td>
<td style="text-align: left;">yes</td>
</tr>
<tr class="even">
<td>8</td>
<td style="text-align: left;"><code>a/+/c/d</code></td>
<td style="text-align: left;">yes</td>
</tr>
<tr class="odd">
<td>9</td>
<td style="text-align: left;"><code>a/b/#</code></td>
<td style="text-align: left;">yes</td>
</tr>
<tr class="even">
<td>10</td>
<td style="text-align: left;"><code>a/b/c</code></td>
<td style="text-align: left;">no!</td>
</tr>
<tr class="odd">
<td>11</td>
<td style="text-align: left;"><code>a/b/c/#</code></td>
<td style="text-align: left;">yes</td>
</tr>
<tr class="even">
<td>12</td>
<td style="text-align: left;"><code>a/b/c/d/#</code></td>
<td style="text-align: left;">yes</td>
</tr>
<tr class="odd">
<td>13</td>
<td style="text-align: left;"><code>a/b/c/d</code></td>
<td style="text-align: left;">yes</td>
</tr>
<tr class="even">
<td>14</td>
<td style="text-align: left;"><code>b/+/c/d</code></td>
<td style="text-align: left;">no!</td>
</tr>
<tr class="odd">
<td>15</td>
<td style="text-align: left;"><code>a/b/c/d/+</code></td>
<td style="text-align: left;">no!</td>
</tr>
</tbody>
</table>

    </section>
</div>


<footer></footer>
<script>
  anchors.options.visible = 'touch';
  anchors.add("h1, h2, h3");
</script>
</body>
</html>